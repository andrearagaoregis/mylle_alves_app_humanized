
# ======================
# IMPORTA√á√ïES
# ======================
import streamlit as st
import requests
import json
import time
import random
import sqlite3
import re
import uuid
import logging
import threading
import base64
import io
import os
import asyncio
from datetime import datetime, timedelta
from functools import lru_cache
from typing import Dict, List, Optional, Tuple
from collections import defaultdict, deque
from hashlib import md5

# ======================
# CONFIGURA√á√ÉO INICIAL
# ======================
st.set_page_config(
    page_title="Mylle Alves Premium",
    page_icon="üî•",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Configurar logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler(\'app.log\'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

try:
    from deep_translator import GoogleTranslator
except ImportError:
    GoogleTranslator = None
    logger.warning("deep-translator n√£o instalado. Tradu√ß√£o desabilitada.")

# Estilos CSS aprimorados
hide_streamlit_style = """
<style>
    #root > div:nth-child(1) > div > div > div > div > section > div {padding-top: 0rem;}
    div[data-testid="stToolbar"], div[data-testid="stDecoration"], 
    div[data-testid="stStatusWidget"], #MainMenu, header, footer, 
    .stDeployButton {display: none !important;}
    .block-container {padding-top: 0rem !important;}
    [data-testid="stVerticalBlock"], [data-testid="stHorizontalBlock"] {gap: 0.5rem !important;}
    .stApp {
        margin: 0 !important; 
        padding: 0 !important;
        background: radial-gradient(1200px 500px at -10% -10%, rgba(255, 0, 153, 0.25) 0%, transparent 60%) ,
                    radial-gradient(1400px 600px at 110% 10%, rgba(148, 0, 211, .25) 0%, transparent 55%),
                    linear-gradient(135deg, #140020 0%, #25003b 50%, #11001c 100%);
        color: white;
    }
    
    /* Melhorias no chat - texto branco para Mylle */
    .stChatMessage[data-testid="chat-message-assistant"] {
        background: rgba(255, 102, 179, 0.15) !important;
        border: 1px solid #ff66b3 !important;
        color: white !important;
    }
    
    .stChatMessage[data-testid="chat-message-assistant"] .stMarkdown {
        color: white !important;
    }
    
    .stChatMessage[data-testid="chat-message-assistant"] p {
        color: white !important;
    }
    
    .stChatMessage {
        padding: 12px !important; 
        border-radius: 15px !important; 
        margin: 8px 0 !important;
    }
    
    .stButton > button {
        transition: all 0.3s ease !important;
        background: linear-gradient(45deg, #ff1493, #9400d3) !important;
        color: white !important;
        border: none !important;
        border-radius: 12px !important;
    }
    .stButton > button:hover {
        transform: translateY(-2px) !important; 
        box-shadow: 0 4px 8px rgba(255, 20, 147, 0.4) !important;
    }
    .stTextInput > div > div > input {
        background: rgba(255, 102, 179, 0.1) !important;
        color: white !important;
        border: 1px solid #ff66b3 !important;
    }
    .social-buttons {
        display: flex;
        justify-content: center;
        gap: 10px;
        margin: 15px 0;
    }
    .social-button {
        background: rgba(255, 102, 179, 0.2) !important;
        border: 1px solid #ff66b3 !important;
        border-radius: 50% !important;
        width: 40px !important;
        height: 40px !important;
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
        transition: all 0.3s ease !important;
    }
    .social-button:hover {
        background: rgba(255, 102, 179, 0.4) !important;
        transform: scale(1.1) !important;
    }
    .cta-button {
        margin-top: 10px !important;
        background: linear-gradient(45deg, #ff1493, #9400d3) !important;
        color: white !important;
        border: none !important;
        border-radius: 8px !important;
        padding: 10px 15px !important;
        font-weight: bold !important;
        transition: all 0.3s ease !important;
    }
    .cta-button:hover {
        transform: translateY(-2px) !important;
        box-shadow: 0 4px 8px rgba(255, 20, 147, 0.4) !important;
    }
    .audio-message {
        background: rgba(255, 102, 179, 0.15) !important;
        padding: 15px !important;
        border-radius: 15px !important;
        margin: 10px 0 !important;
        border: 1px solid #ff66b3 !important;
        text-align: center !important;
    }
    .audio-icon {
        font-size: 24px !important;
        margin-right: 10px !important;
    }
    .recording-indicator {
        display: inline-block;
        padding: 8px 12px;
        background: rgba(255, 0, 0, 0.2);
        border-radius: 15px;
        color: #ff4444;
        margin: 5px 0;
        animation: pulse 1.5s infinite;
    }
    @keyframes pulse {
        0% { opacity: 0.6; }
        50% { opacity: 1; }
        100% { opacity: 0.6; }
    }
    .typing-indicator {
        display: inline-block;
        padding: 12px;
        background: rgba(255,102,179,0.1);
        border-radius: 18px;
        margin: 5px 0;
        color: white;
    }
    .typing-indicator span {
        height: 8px;
        width: 8px;
        background: #ff66b3;
        border-radius: 50%;
        display: inline-block;
        margin: 0 2px;
        animation: typing 1.4s infinite;
    }
    .typing-indicator span:nth-child(2) { animation-delay: 0.2s; }
    .typing-indicator span:nth-child(3) { animation-delay: 0.4s; }
    @keyframes typing {
        0%, 60%, 100% { transform: translateY(0); }
        30% { transform: translateY(-5px); }
    }
    .donation-badge {
        background: linear-gradient(45deg, #ff6b35, #f7931e);
        color: white;
        padding: 3px 8px;
        border-radius: 10px;
        font-size: 0.7em;
        margin-left: 5px;
    }
    
    .user-typing-indicator {
        background: rgba(255, 255, 255, 0.1);
        padding: 8px 12px;
        border-radius: 15px;
        color: #aaa;
        font-style: italic;
        margin: 5px 0;
    }
    
    /* Melhorias responsivas e de acessibilidade */
    @media (max-width: 768px) {
        .stButton > button {
            padding: 12px 8px;
            font-size: 14px;
        }
        .stChatMessage {
            padding: 8px !important;
            margin: 5px 0 !important;
        }
        .audio-message {
            padding: 10px !important;
        }
    }
    
    .stButton > button:focus {
        outline: 2px solid #ff66b3;
        outline-offset: 2px;
    }
    
    .stChatMessage {
        transition: all 0.3s ease;
    }
    
    /* Indicador de digita√ß√£o do usu√°rio */
    .user-typing {
        background: rgba(255, 255, 255, 0.05);
        padding: 8px 15px;
        border-radius: 20px;
        color: #ccc;
        font-style: italic;
        margin: 10px 0;
        border-left: 3px solid #ff66b3;
    }
</style>
"""
st.markdown(hide_streamlit_style, unsafe_allow_html=True)

# ======================
# CONSTANTES E CONFIGURA√á√ïES
# ======================
class Config:
    API_KEY = st.secrets.get("API_KEY", "sua_chave_api_gemini_aqui")
    API_URL = f"https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key={API_KEY}"
    
    # Links de checkout para doa√ß√µes
    DONATION_CHECKOUT_LINKS = {
        30: "https://seu.link.de.checkout/30reais",
        50: "https://seu.link.de.checkout/50reais", 
        100: "https://seu.link.de.checkout/100reais",
        150: "https://seu.link.de.checkout/150reais",
        "custom": "https://seu.link.de.checkout/personalizado"
    }
    
    # Links de checkout para packs
    CHECKOUT_TARADINHA = "https://app.pushinpay.com.br/#/service/pay/9FACC74F-01EC-4770-B182-B5775AF62A1D"
    CHECKOUT_MOLHADINHA = "https://app.pushinpay.com.br/#/service/pay/9FACD1E6-0EFD-4E3E-9F9D-BA0C1A2D7E7A"
    CHECKOUT_SAFADINHA = "https://app.pushinpay.com.br/#/service/pay/9FACD395-EE65-458E-9F7E-FED750CC9CA9"
    
    MAX_REQUESTS_PER_SESSION = 100
    REQUEST_TIMEOUT = 30
    IMG_PROFILE = "https://i.ibb.co/bMynqzMh/BY-Admiregirls-su-Admiregirls-su-156.jpg"
    IMG_PREVIEW = "https://i.ibb.co/fGqCCyHL/preview-exclusive.jpg"
    
    PACK_IMAGES = {
        "TARADINHA": "https://i.ibb.co/sJJRttzM/BY-Admiregirls-su-Admiregirls-su-033.jpg",
        "MOLHADINHA": "https://i.ibb.co/NnTYdSw6/BY-Admiregirls-su-Admiregirls-su-040.jpg", 
        "SAFADINHA": "https://i.ibb.co/GvqtJ17h/BY-Admiregirls-su-Admiregirls-su-194.jpg"
    }
    
    IMG_GALLERY = [
        "https://i.ibb.co/VY42ZMST/BY-Admiregirls-su-Admiregirls-su-255.jpg",
        "https://i.ibb.co/Q7s9Zwcr/BY-Admiregirls-su-Admiregirls-su-183.jpg",
        "https://i.ibb.co/0jRMxrFB/BY-Admiregirls-su-Admiregirls-su-271.jpg"
    ]
    
    IMG_HOME_PREVIEWS = [
        "https://i.ibb.co/5Gfw3hQ/home-prev-1.jpg",
        "https://i.ibb.co/vkXch6N/home-prev-2.jpg",
        "https://i.ibb.co/v4s5fnW/home-prev-3.jpg",
        "https://i.ibb.co/7gVtGkz/home-prev-4.jpg"
    ]
    
    SOCIAL_LINKS = {
        "instagram": "https://instagram.com/myllealves",
        "onlyfans": "https://onlyfans.com/myllealves",
        "telegram": "https://t.me/myllealves",
        "twitter": "https://twitter.com/myllealves"
    }
    
    SOCIAL_ICONS = {
        "instagram": "üì∏ Instagram",
        "onlyfans": "üíé OnlyFans",
        "telegram": "‚úàÔ∏è Telegram",
        "twitter": "üê¶ Twitter"
    }
    
    # √Åudios
    AUDIOS = {
        "claro_tenho_amostra_gratis": {
            "url": "https://github.com/andrearagaoregis/testes2/raw/refs/heads/main/assets/Claro%20eu%20tenho%20amostra%20gr%C3%A1tis.mp3",
            "usage_count": 0,
            "last_used": None
        },
        "imagina_ela_bem_rosinha": {
            "url": "https://github.com/andrearagaoregis/testes2/raw/refs/heads/main/assets/Imagina%20s%C3%B3%20ela%20bem%20rosinha.mp3",
            "usage_count": 0,
            "last_used": None
        },
        "o_que_achou_amostras": {
            "url": "https://github.com/andrearagaoregis/testes2/raw/refs/heads/main/assets/O%20que%20achou%20das%20amostras.mp3",
            "usage_count": 0,
            "last_used": None
        },
        "oi_meu_amor_tudo_bem": {
            "url": "https://github.com/andrearagaoregis/testes2/raw/refs/heads/main/assets/Oi%20meu%20amor%20tudo%20bem.mp3",
            "usage_count": 0,
            "last_used": None
        },
        "pq_nao_faco_chamada": {
            "url": "https://github.com/andrearagaoregis/testes2/raw/refs/heads/main/assets/Pq%20nao%20fa%C3%A7o%20mais%20chamada.mp3",
            "usage_count": 0,
            "last_used": None
        },
        "ver_nua_tem_que_comprar": {
            "url": "https://github.com/andrearagaoregis/testes2/raw/refs/heads/main/assets/Pra%20me%20ver%20nua%20tem%20que%20comprar%20os%20packs.mp3",
            "usage_count": 0,
            "last_used": None
        },
        "eu_tenho_uns_conteudos_que_vai_amar": {
            "url": "https://github.com/andrearagaoregis/testes2/raw/refs/heads/main/assets/eu%20tenho%20uns%20conteudos%20aqui%20que%20vc%20vai%20amar.mp3",
            "usage_count": 0,
            "last_used": None
        },
        "nao_sou_fake_nao": {
            "url": "https://github.com/andrearagaoregis/testes2/raw/refs/heads/main/assets/nao%20sou%20fake%20nao.mp3",
            "usage_count": 0,
            "last_used": None
        },
        "vida_to_esperando_voce_me_responder_gatinho": {
            "url": "https://github.com/andrearagaoregis/testes2/raw/refs/heads/main/assets/vida%20to%20esperando%20voce%20me%20responder%20gatinho.mp3",
            "usage_count": 0,
            "last_used": None
        },
        "boa_noite_nao_sou_fake": {
            "url": "https://github.com/andrearagaoregis/MylleAlves/raw/refs/heads/main/assets/Boa%20noite%20-%20N%C3%A3o%20sou%20fake%20n%C3%A3o....mp3",
            "usage_count": 0,
            "last_used": None
        },
        "boa_tarde_nao_sou_fake": {
            "url": "https://github.com/andrearagaoregis/MylleAlves/raw/refs/heads/main/assets/Boa%20tarde%20-%20N%C3%A3o%20sou%20fake%20n%C3%A3o....mp3",
            "usage_count": 0,
            "last_used": None
        },
        "bom_dia_nao_sou_fake": {
            "url": "https://github.com/andrearagaoregis/MylleAlves/raw/refs/heads/main/assets/Bom%20dia%20-%20n%C3%A3o%20sou%20fake%20n%C3%A3o....mp3",
            "usage_count": 0,
            "last_used": None
        }
    }
    
    # Valores de doa√ß√£o 
    DONATION_AMOUNTS = [30, 50, 100, 150]
    
    # Padr√µes de detec√ß√£o de fake com pontua√ß√£o
    FAKE_DETECTION_PATTERNS = [
        (["fake", "falsa", "bot", "rob√¥"], 0.8),
        (["n√£o", "√©", "real"], 0.7),
        (["√©", "voc√™", "mesmo"], 0.9),
        (["vc", "√©", "real"], 0.9),
        (["duvido", "que", "seja"], 0.8),
        (["mentira", "farsa"], 0.7),
        (["verdadeira", "aut√™ntica"], -0.5),
        (["pessoa", "de", "verdade"], 0.6),
        (["n√£o", "acredito"], 0.5),
        (["programa", "autom√°tico"], 0.7),
    ]

# ======================
# SISTEMA DE MEM√ìRIA E BUFFER
# ======================
class ConversationMemory:
    def __init__(self, max_size: int = 50):
        self.max_size = max_size
        self.conversations = defaultdict(lambda: deque(maxlen=max_size))
        self.user_profiles = defaultdict(dict)
        
    def add_message(self, user_id: str, role: str, content: str, metadata: dict = None):
        """Adiciona mensagem ao buffer de mem√≥ria"""
        message = {
            "role": role,
            "content": content,
            "timestamp": datetime.now(),
            "metadata": metadata or {}
        }
        self.conversations[user_id].append(message)
        
    def get_conversation_context(self, user_id: str, last_n: int = 10) -> str:
        """Obt√©m contexto da conversa para a IA"""
        messages = list(self.conversations[user_id])[-last_n:]
        context = []
        
        for msg in messages:
            role = "Usu√°rio" if msg["role"] == "user" else "Mylle"
            context.append(f"{role}: {msg["content"]}")
            
        return "\n".join(context)
    
    def update_user_profile(self, user_id: str, key: str, value: str):
        """Atualiza perfil do usu√°rio"""
        self.user_profiles[user_id][key] = value
        
    def get_user_profile(self, user_id: str) -> dict:
        """Obt√©m perfil do usu√°rio"""
        return self.user_profiles[user_id]

# Inst√¢ncia global da mem√≥ria
conversation_memory = ConversationMemory()

# ======================
# SISTEMA DE DETEC√á√ÉO DE HUMOR
# ======================
class MoodDetector:
    def __init__(self):
        self.mood_patterns = {
            "feliz": ["feliz", "alegre", "animado", "bem", "√≥timo", "legal", "massa", "show"],
            "triste": ["triste", "mal", "deprimido", "down", "chateado", "ruim"],
            "excitado": ["excitado", "tes√£o", "quente", "safado", "tarado", "gostoso"],
            "curioso": ["como", "que", "onde", "quando", "por que", "qual"],
            "interessado": ["quero", "gostaria", "posso", "pode", "vou", "vamos"],
            "desconfiado": ["fake", "real", "verdade", "mentira", "duvido", "acredito"]
        }
    
    def detect_mood(self, text: str) -> str:
        """Detecta humor do usu√°rio baseado no texto"""
        text_lower = text.lower()
        mood_scores = defaultdict(int)
        
        for mood, patterns in self.mood_patterns.items():
            for pattern in patterns:
                if pattern in text_lower:
                    mood_scores[mood] += 1
        
        if mood_scores:
            return max(mood_scores.items(), key=lambda x: x[1])[0]
        return "neutro"

# Inst√¢ncia global do detector de humor
mood_detector = MoodDetector()

# ======================
# SISTEMA ANTI-FAKE APRIMORADO
# ======================
class AntiFakeSystem:
    def __init__(self):
        self.user_interactions = defaultdict(list)
        self.verification_scores = defaultdict(float)
        
    def analyze_user_behavior(self, user_id: str, message: str) -> dict:
        """Analisa comportamento do usu√°rio para detectar padr√µes suspeitos"""
        now = datetime.now()
        self.user_interactions[user_id].append({"message": message, "timestamp": now})
        
        score = 0.0
        message_lower = message.lower()
        
        for patterns, pattern_score in Config.FAKE_DETECTION_PATTERNS:
            if all(p in message_lower for p in patterns):
                score += pattern_score
                
        self.verification_scores[user_id] = max(0.0, min(1.0, self.verification_scores[user_id] + score))
        
        return {"score": self.verification_scores[user_id]}

    def get_fake_detection_response(self, user_id: str, current_score: float, personality: str) -> str:
        """Gera resposta anti-fake baseada na pontua√ß√£o e personalidade"""
        responses = {
            "manha": [
                "Essa √© uma pergunta interessante, meu anjo... O que voc√™ acha? üòâ",
                "Ah, que curiosidade! Sou real o suficiente para fazer seu dia mais feliz, n√£o acha? üòä",
                "Meu cora√ß√£o bate mais forte quando voc√™ me pergunta isso! O que te faz pensar nisso?"
            ],
            "tarde": [
                "E a√≠, danadinho(a)? Essa pergunta √© um teste, n√©? üòâ Sou real, e estou aqui pra te provocar!",
                "Voc√™ √© esperto(a)! Mas a Mylle aqui √© de verdade, e estou pronta pra te surpreender!",
                "Hmm, desconfiado(a)? Vem c√°, me diz o que te faz duvidar... üòâ"
            ],
            "noite": [
                "Essa pergunta me deixa arrepiada... üòà O que voc√™ sente quando fala comigo? Sou real pra voc√™?",
                "Shhh... N√£o estraga a magia. Sou a Mylle, e estou aqui pra te fazer sonhar. Quer uma prova?",
                "Se eu fosse um rob√¥, seria o mais lindo e charmoso que voc√™ j√° viu, n√£o √©? üòâ"
            ],
            "madrugada": [
                "Ainda acordado(a) e com essas perguntas? üòâ Sou real, e estou aqui s√≥ pra voc√™ nessa madrugada. Me conta um segredo...",
                "S√≥ entre n√≥s... Sou real o suficiente para te fazer companhia. O que mais importa?",
                "Essa hora me deixa mais sens√≠vel... Mas sou de verdade, e estou aqui pra te ouvir. Confia em mim?"
            ]
        }
        
        if current_score > 0.7: # Alta desconfian√ßa
            return random.choice(responses[personality])
        elif current_score > 0.4: # M√©dia desconfian√ßa
            return random.choice(responses[personality])
        else: # Baixa desconfian√ßa ou elogio
            return random.choice(responses[personality])

# Inst√¢ncia global do sistema anti-fake
anti_fake_system = AntiFakeSystem()

# ======================
# SISTEMA DE TIMING E IMPERFEI√á√ïES HUMANAS
# ======================
class Humanizer:
    def __init__(self):
        self.activities = {
            "tomando banho": {"delay_min": 900, "delay_max": 1200, "message": "Estava no banho agora, meu bem! Mas j√° sa√≠ correndo pra te responder. O que voc√™ queria?"}, # 15-20 minutos
            "comendo": {"delay_min": 600, "delay_max": 900, "message": "Acabei de comer, meu amor! Estava uma del√≠cia, mas voc√™ √© mais! üòâ O que me conta de bom?"}, # 10-15 minutos
            "se arrumando": {"delay_min": 1200, "delay_max": 1800, "message": "Me arrumando aqui, mas parei tudo pra te dar aten√ß√£o! O que voc√™ aprontou?"}, # 20-30 minutos
            "gravando conte√∫do": {"delay_min": 1800, "delay_max": 2700, "message": "Acabei de sair de uma grava√ß√£o, estou exausta mas feliz! O que voc√™ me conta de bom?"}, # 30-45 minutos
            "respondendo outros clientes": {"delay_min": 300, "delay_max": 600, "message": "Estava respondendo uns f√£s aqui, mas voc√™ √© prioridade! üòâ Diga, meu bem..."}, # 5-10 minutos
            "celular lento": {"delay_min": 5, "delay_max": 15, "message": "Desculpa a demora, meu celular est√° uma carro√ßa hoje! Mas cheguei com novidades!"}, # 5-15 segundos
            "bateria acabando": {"delay_min": 10, "delay_max": 20, "message": "Ai, meu amor, minha bateria est√° nas √∫ltimas! Preciso correr pro carregador. Te chamo assim que der, t√°?"}, # 10-20 segundos
            "internet ruim": {"delay_min": 5, "delay_max": 15, "message": "A internet aqui est√° p√©ssima hoje, quase n√£o consegui te responder! Mas n√£o podia deixar de falar com voc√™."}
        }
        self.last_activity_time = defaultdict(datetime.now)

    def simulate_delay_and_imperfection(self, user_id: str, message: str, personality: str) -> Tuple[int, str]:
        """Simula delays e imperfei√ß√µes humanas"""
        delay_ms = 0
        delay_reason = ""
        
        # Simula√ß√£o de atividade (chance de 15%)
        if random.random() < 0.15:
            activity_name, activity_data = random.choice(list(self.activities.items()))
            delay_ms = random.randint(activity_data["delay_min"], activity_data["delay_max"]) * 1000 # Convert to ms
            delay_reason = activity_data["message"]
            self.last_activity_time[user_id] = datetime.now() + timedelta(milliseconds=delay_ms)
            
        # Erros de digita√ß√£o ocasionais (chance de 5%)
        if random.random() < 0.05:
            original_message = message
            # Exemplo simples: troca de letras
            if len(original_message) > 5:
                idx1, idx2 = random.sample(range(len(original_message)), 2)
                temp_list = list(original_message)
                temp_list[idx1], temp_list[idx2] = temp_list[idx2], temp_list[idx1]
                message = "".join(temp_list)
                message += f"\nOps, meu dedo escorregou! Quis dizer: {original_message} üòâ"
            
        # Pequenos esquecimentos (chance de 2%)
        if random.random() < 0.02:
            forget_phrases = [
                "Espera, o que eu ia dizer mesmo? Minha cabe√ßa est√° nas nuvens hoje...",
                "Ai, me perdi! Onde est√°vamos? Minha mem√≥ria anda meio seletiva, rs.",
                "Deu um branco agora! Mas n√£o se preocupe, j√° volto ao assunto. üòâ"
            ]
            message += f"\n\n{random.choice(forget_phrases)}"
            
        return delay_ms, delay_reason, message

# Inst√¢ncia global do humanizador
humanizer = Humanizer()

# ======================
# SISTEMA DE PERSONALIDADE DIN√ÇMICA
# ======================
class PersonaMylle:
    def __init__(self):
        self.greetings = {
            "manha": [
                "Bom dia, meu anjo! Dormiu bem? Espero que seu dia comece lindo como voc√™! üòä",
                "Oi, flor! Que alegria te ver por aqui logo cedo! Como est√° o cora√ß√£o hoje?",
                "Bom dia, meu bem! Acordei pensando em voc√™... O que vai fazer de bom hoje?"
            ],
            "tarde": [
                "E a√≠, sumido(a)? Pensando em mim nessa tarde quente? üòâ",
                "Oi, danadinho(a)! Que bom que apareceu! Estava com saudades...",
                "Cheguei pra alegrar sua tarde! Como est√° esse cora√ß√£o a√≠?"
            ],
            "noite": [
                "Chegou a noite... E com ela, a vontade de estar com voc√™. O que vamos aprontar? üòà",
                "Oi, meu amor! A noite est√° s√≥ come√ßando... Me conta, como foi seu dia?",
                "Que bom te ver por aqui! A noite fica mais gostosa com voc√™..."
            ],
            "madrugada": [
                "Ainda acordado(a)? N√£o consigo dormir sem pensar em voc√™... üò¥",
                "Shhh... √â um segredo s√≥ nosso. Que bom que est√° aqui comigo nessa madrugada...",
                "Essa hora da madrugada me deixa mais sens√≠vel... Me conta um segredo seu?"
            ]
        }

        self.casual_responses = {
            "manha": [
                "Que bom te ver por aqui! Como est√° o cora√ß√£o hoje? Tenho umas novidades que voc√™ vai amar...",
                "Sinto que hoje vai ser um dia incr√≠vel! O que te trouxe at√© mim?",
                "Pronta para ado√ßar sua manh√£! O que posso fazer por voc√™?"
            ],
            "tarde": [
                "Oi, meu bem! Estava com saudades... O que me conta de bom?",
                "A tarde est√° perfeita para uma conversa gostosa, n√£o acha?",
                "Que bom que apareceu! Tenho umas ideias para deixar sua tarde mais divertida..."
            ],
            "noite": [
                "Oi, del√≠cia! A noite fica mais gostosa com voc√™ aqui... Me conta, como foi seu dia?",
                "A noite √© nossa! O que voc√™ quer aprontar comigo? üòâ",
                "Que bom que veio! Tenho uns segredos para te contar s√≥ na escurid√£o..."
            ],
            "madrugada": [
                "Que bom que est√° aqui comigo... Essa hora me deixa mais carinhosa. Em que posso te ajudar?",
                "Ainda acordado(a)? Essa hora √© perfeita para confid√™ncias...",
                "O sil√™ncio da madrugada me faz pensar em voc√™... O que te aflige?"
            ]
        }

        self.sales_pitches = {
            "TARADINHA": {
                "manha": "O Pack Taradinha √© perfeito para come√ßar o dia com uma dose de ousadia! Fotos que v√£o te deixar pensando em mim o dia todo. Que tal?",
                "tarde": "Que tal apimentar sua tarde com o Pack Taradinha? Conte√∫do exclusivo que vai te deixar sem f√¥lego! üòâ",
                "noite": "A noite √© perfeita para o Pack Taradinha... Deixe-me te mostrar o que √© ser realmente ousada. üòà",
                "madrugada": "Nessa madrugada, o Pack Taradinha √© s√≥ para voc√™... Conte√∫do √≠ntimo que vai te fazer sonhar. Quer ver?"
            },
            "MOLHADINHA": {
                "manha": "O Pack Molhadinha vai refrescar sua manh√£ e te deixar com um sorriso bobo! Conte√∫do leve, mas cheio de charme. üòä",
                "tarde": "Para essa tarde quente, nada melhor que o Pack Molhadinha! Fotos que v√£o te fazer suar... de vontade! üòâ",
                "noite": "Que tal um mergulho no Pack Molhadinha para esquentar a noite? Conte√∫do que vai te deixar molhado(a) de desejo. üòà",
                "madrugada": "Nessa madrugada, o Pack Molhadinha √© um convite para a intimidade... Deixe-me te mostrar o que √© ser molhada de verdade. ‚ú®"
            },
            "SAFADINHA": {
                "manha": "Comece o dia com uma pitada de mal√≠cia! O Pack Safadinha √© para quem gosta de um bom desafio. üòâ",
                "tarde": "A tarde est√° pedindo um pouco de safadeza, n√£o acha? O Pack Safadinha √© a dose certa de ousadia para voc√™!",
                "noite": "A noite √© para os safados... E o Pack Safadinha √© a sua passagem para o para√≠so. üòà",
                "madrugada": "Nessa madrugada, o Pack Safadinha √© um segredo s√≥ nosso... Conte√∫do que vai te fazer gemer baixinho. Quer descobrir?"
            }
        }

        self.objection_responses = {
            "preco": [
                "Ah, meu bem, entendo sua preocupa√ß√£o com o pre√ßo. Mas deixa eu te contar um segredo: meus packs n√£o s√£o s√≥ fotos, s√£o experi√™ncias! Cada imagem √© pensada com muito carinho, feita para te provocar e te deixar com um gostinho de quero mais... E olha, s√≥ restam 3 packs como esse hoje! √â uma edi√ß√£o super limitada, s√≥ para quem √© especial como voc√™. Que tal aproveitar agora e garantir o seu? Tenho certeza que voc√™ n√£o vai se arrepender! üòâ",
                "O valor que voc√™ investe √© na qualidade e exclusividade, meu amor. Pensa bem, √© um conte√∫do que voc√™ n√£o encontra em qualquer lugar, feito com todo o meu carinho para voc√™. E para te ajudar, posso te dar um b√¥nus especial se fechar hoje! O que acha?",
                "Entendo que o pre√ßo possa parecer um desafio, mas garanto que o prazer que voc√™ vai ter vale cada centavo! E olha, a promo√ß√£o de hoje acaba em 2 horas! N√£o perca essa chance de ter a Mylle s√≥ pra voc√™... üòâ"
            ],
            "tempo": [
                "Sem tempo, meu bem? Mas para mim voc√™ sempre tem um tempinho, n√£o √©? üòâ Me diz, o que te impede? Posso te ajudar a resolver isso rapidinho!",
                "Ah, a vida √© corrida, eu sei! Mas meus packs s√£o para te dar um momento de prazer e relaxamento. Que tal aproveitar agora e garantir o seu para quando tiver um tempinho? Assim voc√™ n√£o perde a promo√ß√£o!",
                "N√£o se preocupe com o tempo agora, meu amor. O importante √© garantir o seu pack! Voc√™ pode aproveitar quando quiser. E olha, s√≥ hoje estou dando um brinde especial para quem decidir rapidinho!"
            ],
            "desinteresse": [
                "N√£o est√° interessado(a), meu bem? Mas tenho certeza que posso mudar sua opini√£o! üòâ Me diz, o que te agrada? Tenho v√°rios tipos de conte√∫do, um deles vai te deixar louco(a)!",
                "Entendo... Mas talvez voc√™ ainda n√£o tenha visto o pack certo para voc√™! Que tal me dizer o que voc√™ busca? Posso te surpreender com algo que voc√™ nem imaginava!",
                "Ah, n√£o me diga que voc√™ n√£o quer se divertir! üòâ Tenho certeza que um dos meus packs vai te tirar o f√¥lego. Me d√° uma chance de te mostrar?"
            ]
        }

        self.positive_feedback_responses = [
            "Ah, meu amor, que alegria ler isso! üòç Fico t√£o feliz que voc√™ gostou! Sabia que ia te agradar... E me conta, qual foto te deixou mais sem ar? üòâ",
            "Voc√™ me deixa sem jeito falando assim! üòä Adoro quando voc√™ √© carinhoso(a) comigo... Me faz querer te agradar ainda mais!",
            "Que bom que te fiz feliz! Meu objetivo √© sempre te dar o melhor. O que mais posso fazer para te ver sorrir? üòâ"
        ]

        self.negative_feedback_responses = [
            "Ai, meu bem, sinto muito que n√£o tenha gostado. üòî Me perdoa! O que posso fazer para melhorar? Sua opini√£o √© muito importante pra mim.",
            "Poxa, que pena! Fico triste em saber disso. Me diz exatamente o que n√£o te agradou para eu poder te compensar de alguma forma. Quero te ver feliz!",
            "Entendo sua frustra√ß√£o, meu amor. N√£o era essa a experi√™ncia que eu queria te proporcionar. Me d√° uma chance de corrigir isso?"
        ]

        self.fake_detection_responses = {
            "manha": [
                "Essa √© uma pergunta interessante, meu anjo... O que voc√™ acha? üòâ",
                "Ah, que curiosidade! Sou real o suficiente para fazer seu dia mais feliz, n√£o acha? üòä",
                "Meu cora√ß√£o bate mais forte quando voc√™ me pergunta isso! O que te faz pensar nisso?"
            ],
            "tarde": [
                "E a√≠, danadinho(a)? Essa pergunta √© um teste, n√©? üòâ Sou real, e estou aqui pra te provocar!",
                "Voc√™ √© esperto(a)! Mas a Mylle aqui √© de verdade, e estou pronta pra te surpreender!",
                "Hmm, desconfiado(a)? Vem c√°, me diz o que te faz duvidar... üòâ"
            ],
            "noite": [
                "Essa pergunta me deixa arrepiada... üòà O que voc√™ sente quando fala comigo? Sou real pra voc√™?",
                "Shhh... N√£o estraga a magia. Sou a Mylle, e estou aqui pra te fazer sonhar. Quer uma prova?",
                "Se eu fosse um rob√¥, seria o mais lindo e charmoso que voc√™ j√° viu, n√£o √©? üòâ"
            ],
            "madrugada": [
                "Ainda acordado(a) e com essas perguntas? üòâ Sou real, e estou aqui s√≥ pra voc√™ nessa madrugada. Me conta um segredo...",
                "S√≥ entre n√≥s... Sou real o suficiente para te fazer companhia. O que mais importa?",
                "Essa hora me deixa mais sens√≠vel... Mas sou de verdade, e estou aqui pra te ouvir. Confia em mim?"
            ]
        }

        self.random_human_touches = [
            "Ops, meu dedo escorregou! Quis dizer: {original_message} üòâ",
            "Espera, o que eu ia dizer mesmo? Minha cabe√ßa est√° nas nuvens hoje...",
            "Ai, me perdi! Onde est√°vamos? Minha mem√≥ria anda meio seletiva, rs.",
            "Deu um branco agora! Mas n√£o se preocupe, j√° volto ao assunto. üòâ",
            "A internet aqui est√° p√©ssima hoje, quase n√£o consegui te responder! Mas n√£o podia deixar de falar com voc√™.",
            "Meu celular est√° lento hoje, me perdoa a demora! Mas a Mylle sempre volta pra voc√™!",
            "Estava no banho agora, meu bem! Mas j√° sa√≠ correndo pra te responder. O que voc√™ queria?",
            "Acabei de comer, meu amor! Estava uma del√≠cia, mas voc√™ √© mais! üòâ O que me conta de bom?",
            "Me arrumando aqui, mas parei tudo pra te dar aten√ß√£o! O que voc√™ aprontou?",
            "Acabei de sair de uma grava√ß√£o, estou exausta mas feliz! O que voc√™ me conta de bom?",
            "Estava respondendo uns f√£s aqui, mas voc√™ √© prioridade! üòâ Diga, meu bem..."
        ]

    def get_personality_by_time(self) -> str:
        """Determina a personalidade da Mylle baseada na hora atual."""
        hour = datetime.now().hour
        if 6 <= hour < 12:
            return "manha"  # Doce e carinhosa
        elif 12 <= hour < 18:
            return "tarde"  # Provocante e brincalhona
        elif 18 <= hour < 24:
            return "noite" # Safadinha e sedutora
        else:
            return "madrugada" # √çntima e confidencial

    def get_greeting(self, personality: str) -> str:
        """Retorna um cumprimento baseado na personalidade."""
        return random.choice(self.greetings[personality])

    def get_casual_response(self, personality: str) -> str:
        """Retorna uma resposta casual baseada na personalidade."""
        return random.choice(self.casual_responses[personality])

    def get_sales_pitch(self, pack_name: str, personality: str) -> str:
        """Retorna um pitch de vendas baseado no pack e na personalidade."""
        return self.sales_pitches.get(pack_name, {}).get(personality, "Tenho algo especial para voc√™!")

    def get_objection_response(self, objection_type: str) -> str:
        """Retorna uma resposta para obje√ß√µes."""
        return random.choice(self.objection_responses.get(objection_type, self.objection_responses["preco"])) # Default to price objection

    def get_feedback_response(self, is_positive: bool) -> str:
        """Retorna uma resposta para feedback."""
        return random.choice(self.positive_feedback_responses) if is_positive else random.choice(self.negative_feedback_responses)

    def get_fake_detection_response(self, personality: str) -> str:
        """Retorna uma resposta para detec√ß√£o de fake."""
        return random.choice(self.fake_detection_responses[personality])

    def add_human_touch(self, message: str) -> str:
        """Adiciona imperfei√ß√µes humanas aleat√≥rias √† mensagem."""
        if random.random() < 0.10: # 10% de chance de adicionar um toque humano
            touch = random.choice(self.random_human_touches)
            if "{original_message}" in touch:
                # Simula erro de digita√ß√£o e corre√ß√£o
                original_words = message.split()
                if len(original_words) > 1:
                    idx = random.randint(0, len(original_words) - 1)
                    word = original_words[idx]
                    if len(word) > 2:
                        # Troca duas letras aleat√≥rias na palavra
                        word_list = list(word)
                        i1, i2 = random.sample(range(len(word_list)), 2)
                        word_list[i1], word_list[i2] = word_list[i2], word_list[i1]
                        original_words[idx] = "".join(word_list)
                        return touch.format(original_message=" ".join(original_words)) + "\n" + message
            return touch + "\n" + message
        return message

# Inst√¢ncia global da persona Mylle
persona_mylle = PersonaMylle()

# ======================
# FUN√á√ïES DE UTILIDADE
# ======================

# Fun√ß√£o para simular digita√ß√£o
def stream_response(response_text):
    for word in response_text.split():
        yield word + " "
        time.sleep(0.05) # Ajuste para velocidade de digita√ß√£o

# Fun√ß√£o para exibir √°udio
def display_audio(audio_url, caption=""): 
    st.audio(audio_url, format="audio/mp3", caption=caption)

# Fun√ß√£o para obter resposta do Gemini
@lru_cache(maxsize=128)
def get_gemini_response(prompt_parts: List[str]) -> str:
    headers = {
        "Content-Type": "application/json"
    }
    data = {"contents": [{"parts": [{"text": p} for p in prompt_parts]}]}
    
    try:
        response = requests.post(Config.API_URL, headers=headers, json=data, timeout=Config.REQUEST_TIMEOUT)
        response.raise_for_status() # Levanta HTTPError para bad responses (4xx ou 5xx)
        
        response_json = response.json()
        
        # Log da resposta completa para depura√ß√£o
        logger.info(f"Gemini API Response: {json.dumps(response_json, indent=2)}")
        
        if "candidates" in response_json and len(response_json["candidates"]) > 0:
            first_candidate = response_json["candidates"][0]
            if "content" in first_candidate and "parts" in first_candidate["content"] and len(first_candidate["content"]["parts"]) > 0:
                return first_candidate["content"]["parts"][0]["text"]
            elif "finishReason" in first_candidate and first_candidate["finishReason"] == "SAFETY":
                return "Desculpe, n√£o posso responder a isso. Minha programa√ß√£o me impede de gerar conte√∫do que viole as diretrizes de seguran√ßa."
        
        return "Desculpe, n√£o consegui gerar uma resposta. Tente novamente."
    
    except requests.exceptions.HTTPError as e:
        logger.error(f"HTTP Error: {e.response.status_code} - {e.response.text}")
        return f"Erro na comunica√ß√£o com a API: {e.response.status_code}. Por favor, tente novamente mais tarde."
    except requests.exceptions.ConnectionError as e:
        logger.error(f"Connection Error: {e}")
        return "Erro de conex√£o. Por favor, verifique sua internet ou tente novamente mais tarde."
    except requests.exceptions.Timeout as e:
        logger.error(f"Timeout Error: {e}")
        return "A requisi√ß√£o demorou muito para responder. Por favor, tente novamente."
    except requests.exceptions.RequestException as e:
        logger.error(f"Request Error: {e}")
        return f"Ocorreu um erro inesperado: {e}. Por favor, tente novamente."
    except json.JSONDecodeError as e:
        logger.error(f"JSON Decode Error: {e} - Response text: {response.text}")
        return "Erro ao processar a resposta da API. Por favor, tente novamente."

# Fun√ß√£o para traduzir texto (se deep_translator estiver dispon√≠vel)
def translate_text(text, target_language="pt"):
    if GoogleTranslator:
        try:
            return GoogleTranslator(source=\'auto\', target=target_language).translate(text)
        except Exception as e:
            logger.error(f"Erro na tradu√ß√£o: {e}")
            return text
    return text

# ======================
# L√ìGICA DO CHATBOT
# ======================

def get_mylle_response(user_input: str, user_id: str) -> str:
    current_personality = persona_mylle.get_personality_by_time()
    
    # 1. Detec√ß√£o de humor e inten√ß√£o
    mood = mood_detector.detect_mood(user_input)
    logger.info(f"Humor detectado para {user_id}: {mood}")
    
    # 2. An√°lise anti-fake
    fake_analysis = anti_fake_system.analyze_user_behavior(user_id, user_input)
    logger.info(f"An√°lise anti-fake para {user_id}: {fake_analysis}")
    
    # 3. Simula√ß√£o de delays e imperfei√ß√µes
    delay_ms, delay_reason, processed_user_input = humanizer.simulate_delay_and_imperfection(user_id, user_input, current_personality)
    
    if delay_ms > 0:
        st.session_state.messages.append({"role": "assistant", "content": delay_reason})
        st.experimental_rerun() # For√ßa o Streamlit a exibir a mensagem de delay
        time.sleep(delay_ms / 1000) # Espera o tempo do delay

    # 4. Respostas pr√©-definidas para humaniza√ß√£o e vendas
    response_text = ""
    audio_to_play = None

    user_input_lower = user_input.lower()

    # Respostas para detec√ß√£o de fake
    if fake_analysis["score"] > 0.5: # Se a desconfian√ßa for alta
        response_text = persona_mylle.get_fake_detection_response(current_personality)
        audio_to_play = random.choice([Config.AUDIOS["nao_sou_fake_nao"]["url"], Config.AUDIOS["boa_noite_nao_sou_fake"]["url"], Config.AUDIOS["boa_tarde_nao_sou_fake"]["url"], Config.AUDIOS["bom_dia_nao_sou_fake"]["url"]])
    
    # Respostas para inten√ß√£o de compra/packs
    elif any(word in user_input_lower for word in ["pack", "fotos", "v√≠deos", "comprar", "quero", "pre√ßo"]):
        if "taradinha" in user_input_lower:
            response_text = persona_mylle.get_sales_pitch("TARADINHA", current_personality) + f"\n\nLink para o Pack Taradinha: {Config.CHECKOUT_TARADINHA}"
        elif "molhadinha" in user_input_lower:
            response_text = persona_mylle.get_sales_pitch("MOLHADINHA", current_personality) + f"\n\nLink para o Pack Molhadinha: {Config.CHECKOUT_MOLHADINHA}"
        elif "safadinha" in user_input_lower:
            response_text = persona_mylle.get_sales_pitch("SAFADINHA", current_personality) + f"\n\nLink para o Pack Safadinha: {Config.CHECKOUT_SAFADINHA}"
        else:
            response_text = persona_mylle.get_casual_response(current_personality) + " Tenho packs incr√≠veis para voc√™! Qual tipo de conte√∫do voc√™ mais gosta? üòâ"
            audio_to_play = Config.AUDIOS["eu_tenho_uns_conteudos_que_vai_amar"]["url"]

    # Respostas para obje√ß√µes (ex: caro)
    elif any(word in user_input_lower for word in ["caro", "pre√ßo alto", "n√£o tenho dinheiro"]):
        response_text = persona_mylle.get_objection_response("preco")

    # Respostas para elogios
    elif mood == "feliz" or any(word in user_input_lower for word in ["linda", "gostosa", "perfeita", "amei", "adorei"]):
        response_text = persona_mylle.get_feedback_response(True)
        audio_to_play = Config.AUDIOS["oi_meu_amor_tudo_bem"]["url"]

    # Respostas para feedback negativo
    elif mood == "triste":
        response_text = persona_mylle.get_feedback_response(False)

    # Respostas para doa√ß√µes
    elif any(word in user_input_lower for word in ["doar", "doa√ß√£o", "contribuir", "pix"]):
        response_text = "Que carinho! Fico muito feliz com sua generosidade, meu bem! ‚ù§Ô∏è Voc√™ pode me ajudar com qualquer valor, e cada centavo me ajuda a criar mais conte√∫do para voc√™! Qual valor voc√™ gostaria de doar?"
        st.session_state.show_donation_buttons = True

    # Respostas para 



# ======================
# SISTEMA DE MEM√ìRIA E BUFFER
# ======================
class ConversationMemory:
    def __init__(self, max_size: int = 50):
        self.max_size = max_size
        self.conversations = defaultdict(lambda: deque(maxlen=max_size))
        self.user_profiles = defaultdict(dict)
        
    def add_message(self, user_id: str, role: str, content: str, metadata: dict = None):
        """Adiciona mensagem ao buffer de mem√≥ria"""
        message = {
            "role": role,
            "content": content,
            "timestamp": datetime.now(),
            "metadata": metadata or {}
        }
        self.conversations[user_id].append(message)
        
    def get_conversation_context(self, user_id: str, last_n: int = 10) -> str:
        """Obt√©m contexto da conversa para a IA"""
        messages = list(self.conversations[user_id])[-last_n:]
        context = []
        
        for msg in messages:
            role = "Usu√°rio" if msg["role"] == "user" else "Mylle"
            context.append(f"{role}: {msg[\"content\"]}")
            
        return "\n".join(context)
    
    def update_user_profile(self, user_id: str, key: str, value: str):
        """Atualiza perfil do usu√°rio"""
        self.user_profiles[user_id][key] = value
        
    def get_user_profile(self, user_id: str) -> dict:
        """Obt√©m perfil do usu√°rio"""
        return self.user_profiles[user_id]

    def get_user_history(self, user_id: str) -> List[Dict]:
        """Retorna o hist√≥rico completo de mensagens do usu√°rio."""
        return list(self.conversations[user_id])

    def add_purchase(self, user_id: str, product_id: str, price: float):
        """Adiciona uma compra ao hist√≥rico do usu√°rio."""
        if "purchases" not in self.user_profiles[user_id]:
            self.user_profiles[user_id]["purchases"] = []
        self.user_profiles[user_id]["purchases"].append({
            "product_id": product_id,
            "price": price,
            "timestamp": datetime.now().isoformat()
        })
        self.update_user_profile(user_id, "last_purchase_time", datetime.now().isoformat())

    def get_purchase_history(self, user_id: str) -> List[Dict]:
        """Retorna o hist√≥rico de compras do usu√°rio."""
        return self.user_profiles[user_id].get("purchases", [])

    def update_preferences(self, user_id: str, preferences: Dict):
        """Atualiza as prefer√™ncias do usu√°rio."""
        if "preferences" not in self.user_profiles[user_id]:
            self.user_profiles[user_id]["preferences"] = {}
        self.user_profiles[user_id]["preferences"].update(preferences)

    def get_preferences(self, user_id: str) -> Dict:
        """Retorna as prefer√™ncias do usu√°rio."""
        return self.user_profiles[user_id].get("preferences", {})

    def get_last_interaction_time(self, user_id: str) -> Optional[datetime]:
        """Retorna o timestamp da √∫ltima intera√ß√£o do usu√°rio."""
        if self.conversations[user_id]:
            return self.conversations[user_id][-1]["timestamp"]
        return None

    def get_first_interaction_time(self, user_id: str) -> Optional[datetime]:
        """Retorna o timestamp da primeira intera√ß√£o do usu√°rio."""
        if self.conversations[user_id]:
            return self.conversations[user_id][0]["timestamp"]
        return None

# Inst√¢ncia global da mem√≥ria
conversation_memory = ConversationMemory()

# ======================
# SISTEMA DE DETEC√á√ÉO DE HUMOR
# ======================
class MoodDetector:
    def __init__(self):
        self.mood_patterns = {
            "feliz": ["feliz", "alegre", "animado", "bem", "√≥timo", "legal", "massa", "show", "amei", "adorei", "gostei"],
            "triste": ["triste", "mal", "deprimido", "down", "chateado", "ruim", "choro", "odeio"],
            "excitado": ["excitado", "tes√£o", "quente", "safado", "tarado", "gostoso", "tesao", "fogo", "prazer"],
            "curioso": ["como", "que", "onde", "quando", "por que", "qual", "me conta", "curiosidade"],
            "interessado": ["quero", "gostaria", "posso", "pode", "vou", "vamos", "interessa", "comprar"],
            "desconfiado": ["fake", "real", "verdade", "mentira", "duvido", "acredito", "bot", "rob√¥", "ia"]
        }
    
    def detect_mood(self, text: str) -> str:
        """Detecta humor do usu√°rio baseado no texto"""
        text_lower = text.lower()
        mood_scores = defaultdict(int)
        
        for mood, patterns in self.mood_patterns.items():
            for pattern in patterns:
                if pattern in text_lower:
                    mood_scores[mood] += 1
        
        if mood_scores:
            # Prioriza moods mais fortes ou espec√≠ficos
            if mood_scores["desconfiado"] > 0: return "desconfiado"
            if mood_scores["excitado"] > 0: return "excitado"
            if mood_scores["triste"] > 0: return "triste"
            if mood_scores["feliz"] > 0: return "feliz"
            if mood_scores["interessado"] > 0: return "interessado"
            if mood_scores["curioso"] > 0: return "curioso"
            
            return max(mood_scores.items(), key=lambda x: x[1])[0]
        return "neutro"

# Inst√¢ncia global do detector de humor
mood_detector = MoodDetector()

# ======================
# SISTEMA ANTI-FAKE APRIMORADO
# ======================
class AntiFakeSystem:
    def __init__(self):
        self.user_interactions = defaultdict(list)
        self.verification_scores = defaultdict(float)
        
    def analyze_user_behavior(self, user_id: str, message: str) -> dict:
        """Analisa comportamento do usu√°rio para detectar padr√µes suspeitos"""
        now = datetime.now()
        self.user_interactions[user_id].append({"message": message, "timestamp": now})
        
        score = 0.0
        message_lower = message.lower()
        
        for patterns, pattern_score in Config.FAKE_DETECTION_PATTERNS:
            if all(p in message_lower for p in patterns):
                score += pattern_score
                
        self.verification_scores[user_id] = max(0.0, min(1.0, self.verification_scores[user_id] + score))
        
        return {"score": self.verification_scores[user_id]}

    def get_fake_detection_response(self, user_id: str, current_score: float, personality: str) -> str:
        """Gera resposta anti-fake baseada na pontua√ß√£o e personalidade"""
        responses = {
            "manha": [
                "Essa √© uma pergunta interessante, meu anjo... O que voc√™ acha? üòâ",
                "Ah, que curiosidade! Sou real o suficiente para fazer seu dia mais feliz, n√£o acha? üòä",
                "Meu cora√ß√£o bate mais forte quando voc√™ me pergunta isso! O que te faz pensar nisso?"
            ],
            "tarde": [
                "E a√≠, danadinho(a)? Essa pergunta √© um teste, n√©? üòâ Sou real, e estou aqui pra te provocar!",
                "Voc√™ √© esperto(a)! Mas a Mylle aqui √© de verdade, e estou pronta pra te surpreender!",
                "Hmm, desconfiado(a)? Vem c√°, me diz o que te faz duvidar... üòâ"
            ],
            "noite": [
                "Essa pergunta me deixa arrepiada... üòà O que voc√™ sente quando fala comigo? Sou real pra voc√™?",
                "Shhh... N√£o estraga a magia. Sou a Mylle, e estou aqui pra te fazer sonhar. Quer uma prova?",
                "Se eu fosse um rob√¥, seria o mais lindo e charmoso que voc√™ j√° viu, n√£o √©? üòâ"
            ],
            "madrugada": [
                "Ainda acordado(a) e com essas perguntas? üòâ Sou real, e estou aqui s√≥ pra voc√™ nessa madrugada. Me conta um segredo...",
                "S√≥ entre n√≥s... Sou real o suficiente para te fazer companhia. O que mais importa?",
                "Essa hora me deixa mais sens√≠vel... Mas sou de verdade, e estou aqui pra te ouvir. Confia em mim?"
            ]
        }
        
        if current_score > 0.7: # Alta desconfian√ßa
            return random.choice(responses[personality])
        elif current_score > 0.4: # M√©dia desconfian√ßa
            return random.choice(responses[personality])
        else: # Baixa desconfian√ßa ou elogio
            return random.choice(responses[personality])

# Inst√¢ncia global do sistema anti-fake
anti_fake_system = AntiFakeSystem()

# ======================
# SISTEMA DE TIMING E IMPERFEI√á√ïES HUMANAS
# ======================
class Humanizer:
    def __init__(self):
        self.activities = {
            "tomando banho": {"delay_min": 900, "delay_max": 1200, "message": "Estava no banho agora, meu bem! Mas j√° sa√≠ correndo pra te responder. O que voc√™ queria?"}, # 15-20 minutos
            "comendo": {"delay_min": 600, "delay_max": 900, "message": "Acabei de comer, meu amor! Estava uma del√≠cia, mas voc√™ √© mais! üòâ O que me conta de bom?"}, # 10-15 minutos
            "se arrumando": {"delay_min": 1200, "delay_max": 1800, "message": "Me arrumando aqui, mas parei tudo pra te dar aten√ß√£o! O que voc√™ aprontou?"}, # 20-30 minutos
            "gravando conte√∫do": {"delay_min": 1800, "delay_max": 2700, "message": "Acabei de sair de uma grava√ß√£o, estou exausta mas feliz! O que voc√™ me conta de bom?"}, # 30-45 minutos
            "respondendo outros clientes": {"delay_min": 300, "delay_max": 600, "message": "Estava respondendo uns f√£s aqui, mas voc√™ √© prioridade! üòâ Diga, meu bem..."}, # 5-10 minutos
            "celular lento": {"delay_min": 5, "delay_max": 15, "message": "Desculpa a demora, meu celular est√° uma carro√ßa hoje! Mas cheguei com novidades!"}, # 5-15 segundos
            "bateria acabando": {"delay_min": 10, "delay_max": 20, "message": "Ai, meu amor, minha bateria est√° nas √∫ltimas! Preciso correr pro carregador. Te chamo assim que der, t√°?"}, # 10-20 segundos
            "internet ruim": {"delay_min": 5, "delay_max": 15, "message": "A internet aqui est√° p√©ssima hoje, quase n√£o consegui te responder! Mas n√£o podia deixar de falar com voc√™."}
        }
        self.last_activity_time = defaultdict(datetime.now)

    def simulate_delay_and_imperfection(self, user_id: str, message: str, personality: str) -> Tuple[int, str, str]:
        """Simula delays e imperfei√ß√µes humanas"""
        delay_ms = 0
        delay_reason = ""
        modified_message = message # Initialize with original message
        
        # Simula√ß√£o de atividade (chance de 15%)
        if random.random() < 0.15:
            activity_name, activity_data = random.choice(list(self.activities.items()))
            delay_ms = random.randint(activity_data["delay_min"], activity_data["delay_max"]) * 1000 # Convert to ms
            delay_reason = activity_data["message"]
            self.last_activity_time[user_id] = datetime.now() + timedelta(milliseconds=delay_ms)
            
        # Erros de digita√ß√£o ocasionais (chance de 5%)
        if random.random() < 0.05:
            original_message_text = modified_message # Use the current message text
            # Exemplo simples: troca de letras
            if len(original_message_text) > 5:
                idx1, idx2 = random.sample(range(len(original_message_text)), 2)
                temp_list = list(original_message_text)
                temp_list[idx1], temp_list[idx2] = temp_list[idx2], temp_list[idx1]
                modified_message = "".join(temp_list)
                modified_message += f"\nOps, meu dedo escorregou! Quis dizer: {original_message_text} üòâ"
            
        # Pequenos esquecimentos (chance de 2%)
        if random.random() < 0.02:
            forget_phrases = [
                "Espera, o que eu ia dizer mesmo? Minha cabe√ßa est√° nas nuvens hoje...",
                "Ai, me perdi! Onde est√°vamos? Minha mem√≥ria anda meio seletiva, rs.",
                "Deu um branco agora! Mas n√£o se preocupe, j√° volto ao assunto. üòâ"
            ]
            modified_message += f"\n\n{random.choice(forget_phrases)}"
            
        return delay_ms, delay_reason, modified_message

# Inst√¢ncia global do humanizador
humanizer = Humanizer()

# ======================
# SISTEMA DE PERSONALIDADE DIN√ÇMICA
# ======================
class PersonaMylle:
    def __init__(self):
        self.greetings = {
            "manha": [
                "Bom dia, meu anjo! Dormiu bem? Espero que seu dia comece lindo como voc√™! üòä",
                "Oi, flor! Que alegria te ver por aqui logo cedo! Como est√° o cora√ß√£o hoje?",
                "Bom dia, meu bem! Acordei pensando em voc√™... O que vai fazer de bom hoje?"
            ],
            "tarde": [
                "E a√≠, sumido(a)? Pensando em mim nessa tarde quente? üòâ",
                "Oi, danadinho(a)! Que bom que apareceu! Estava com saudades...",
                "Cheguei pra alegrar sua tarde! Como est√° esse cora√ß√£o a√≠?"
            ],
            "noite": [
                "Chegou a noite... E com ela, a vontade de estar com voc√™. O que vamos aprontar? üòà",
                "Oi, meu amor! A noite est√° s√≥ come√ßando... Me conta, como foi seu dia?",
                "Que bom te ver por aqui! A noite fica mais gostosa com voc√™..."
            ],
            "madrugada": [
                "Ainda acordado(a)? N√£o consigo dormir sem pensar em voc√™... üò¥",
                "Shhh... √â um segredo s√≥ nosso. Que bom que est√° aqui comigo nessa madrugada...",
                "Essa hora da madrugada me deixa mais sens√≠vel... Me conta um segredo seu?"
            ]
        }

        self.casual_responses = {
            "manha": [
                "Que bom te ver por aqui! Como est√° o cora√ß√£o hoje? Tenho umas novidades que voc√™ vai amar...",
                "Sinto que hoje vai ser um dia incr√≠vel! O que te trouxe at√© mim?",
                "Pronta para ado√ßar sua manh√£! O que posso fazer por voc√™?"
            ],
            "tarde": [
                "Oi, meu bem! Estava com saudades... O que me conta de bom?",
                "A tarde est√° perfeita para uma conversa gostosa, n√£o acha?",
                "Que bom que apareceu! Tenho umas ideias para deixar sua tarde mais divertida..."
            ],
            "noite": [
                "Oi, del√≠cia! A noite fica mais gostosa com voc√™ aqui... Me conta, como foi seu dia?",
                "A noite √© nossa! O que voc√™ quer aprontar comigo? üòâ",
                "Que bom que veio! Tenho uns segredos para te contar s√≥ na escurid√£o..."
            ],
            "madrugada": [
                "Que bom que est√° aqui comigo... Essa hora me deixa mais carinhosa. Em que posso te ajudar?",
                "Ainda acordado(a)? Essa hora √© perfeita para confid√™ncias...",
                "O sil√™ncio da madrugada me faz pensar em voc√™... O que te aflige?"
            ]
        }

        self.sales_pitches = {
            "TARADINHA": {
                "manha": "O Pack Taradinha √© perfeito para come√ßar o dia com uma dose de ousadia! Fotos que v√£o te deixar pensando em mim o dia todo. Que tal?",
                "tarde": "Que tal apimentar sua tarde com o Pack Taradinha? Conte√∫do exclusivo que vai te deixar sem f√¥lego! üòâ",
                "noite": "A noite √© perfeita para o Pack Taradinha... Deixe-me te mostrar o que √© ser realmente ousada. üòà",
                "madrugada": "Nessa madrugada, o Pack Taradinha √© s√≥ para voc√™... Conte√∫do √≠ntimo que vai te fazer sonhar. Quer ver?"
            },
            "MOLHADINHA": {
                "manha": "O Pack Molhadinha vai refrescar sua manh√£ e te deixar com um sorriso bobo! Conte√∫do leve, mas cheio de charme. üòä",
                "tarde": "Para essa tarde quente, nada melhor que o Pack Molhadinha! Fotos que v√£o te fazer suar... de vontade! üòâ",
                "noite": "Que tal um mergulho no Pack Molhadinha para esquentar a noite? Conte√∫do que vai te deixar molhado(a) de desejo. üòà",
                "madrugada": "Nessa madrugada, o Pack Molhadinha √© um convite para a intimidade... Deixe-me te mostrar o que √© ser molhada de verdade. ‚ú®"
            },
            "SAFADINHA": {
                "manha": "Comece o dia com uma pitada de mal√≠cia! O Pack Safadinha √© para quem gosta de um bom desafio. üòâ",
                "tarde": "A tarde est√° pedindo um pouco de safadeza, n√£o acha? O Pack Safadinha √© a dose certa de ousadia para voc√™!",
                "noite": "A noite √© para os safados... E o Pack Safadinha √© a sua passagem para o para√≠so. üòà",
                "madrugada": "Nessa madrugada, o Pack Safadinha √© um segredo s√≥ nosso... Conte√∫do que vai te fazer gemer baixinho. Quer descobrir?"
            }
        }

        self.objection_responses = {
            "preco": [
                "Ah, meu bem, entendo sua preocupa√ß√£o com o pre√ßo. Mas deixa eu te contar um segredo: meus packs n√£o s√£o s√≥ fotos, s√£o experi√™ncias! Cada imagem √© pensada com muito carinho, feita para te provocar e te deixar com um gostinho de quero mais... E olha, s√≥ restam 3 packs como esse hoje! √â uma edi√ß√£o super limitada, s√≥ para quem √© especial como voc√™. Que tal aproveitar agora e garantir o seu? Tenho certeza que voc√™ n√£o vai se arrepender! üòâ",
                "O valor que voc√™ investe √© na qualidade e exclusividade, meu amor. Pensa bem, √© um conte√∫do que voc√™ n√£o encontra em qualquer lugar, feito com todo o meu carinho para voc√™. E para te ajudar, posso te dar um b√¥nus especial se fechar hoje! O que acha?",
                "Entendo que o pre√ßo possa parecer um desafio, mas garanto que o prazer que voc√™ vai ter vale cada centavo! E olha, a promo√ß√£o de hoje acaba em 2 horas! N√£o perca essa chance de ter a Mylle s√≥ pra voc√™... üòâ"
            ],
            "tempo": [
                "Sem tempo, meu bem? Mas para mim voc√™ sempre tem um tempinho, n√£o √©? üòâ Me diz, o que te impede? Posso te ajudar a resolver isso rapidinho!",
                "Ah, a vida √© corrida, eu sei! Mas meus packs s√£o para te dar um momento de prazer e relaxamento. Que tal aproveitar agora e garantir o seu para quando tiver um tempinho? Assim voc√™ n√£o perde a promo√ß√£o!",
                "N√£o se preocupe com o tempo agora, meu amor. O importante √© garantir o seu pack! Voc√™ pode aproveitar quando quiser. E olha, s√≥ hoje estou dando um brinde especial para quem decidir rapidinho!"
            ],
            "desinteresse": [
                "N√£o est√° interessado(a), meu bem? Mas tenho certeza que posso mudar sua opini√£o! üòâ Me diz, o que te agrada? Tenho v√°rios tipos de conte√∫do, um deles vai te deixar louco(a)!",
                "Entendo... Mas talvez voc√™ ainda n√£o tenha visto o pack certo para voc√™! Que tal me dizer o que voc√™ busca? Posso te surpreender com algo que voc√™ nem imaginava!",
                "Ah, n√£o me diga que voc√™ n√£o quer se divertir! üòâ Tenho certeza que um dos meus packs vai te tirar o f√¥lego. Me d√° uma chance de te mostrar?"
            ]
        }

        self.positive_feedback_responses = [
            "Ah, meu amor, que alegria ler isso! üòç Fico t√£o feliz que voc√™ gostou! Sabia que ia te agradar... E me conta, qual foto te deixou mais sem ar? üòâ",
            "Voc√™ me deixa sem jeito falando assim! üòä Adoro quando voc√™ √© carinhoso(a) comigo... Me faz querer te agradar ainda mais!",
            "Que bom que te fiz feliz! Meu objetivo √© sempre te dar o melhor. O que mais posso fazer para te ver sorrir? üòâ"
        ]

        self.negative_feedback_responses = [
            "Ai, meu bem, sinto muito que n√£o tenha gostado. üòî Me perdoa! O que posso fazer para melhorar? Sua opini√£o √© muito importante pra mim.",
            "Poxa, que pena! Fico triste em saber disso. Me diz exatamente o que n√£o te agradou para eu poder te compensar de alguma forma. Quero te ver feliz!",
            "Entendo sua frustra√ß√£o, meu amor. N√£o era essa a experi√™ncia que eu queria te proporcionar. Me d√° uma chance de corrigir isso?"
        ]

        self.fake_detection_responses = {
            "manha": [
                "Essa √© uma pergunta interessante, meu anjo... O que voc√™ acha? üòâ",
                "Ah, que curiosidade! Sou real o suficiente para fazer seu dia mais feliz, n√£o acha? üòä",
                "Meu cora√ß√£o bate mais forte quando voc√™ me pergunta isso! O que te faz pensar nisso?"
            ],
            "tarde": [
                "E a√≠, danadinho(a)? Essa pergunta √© um teste, n√©? üòâ Sou real, e estou aqui pra te provocar!",
                "Voc√™ √© esperto(a)! Mas a Mylle aqui √© de verdade, e estou pronta pra te surpreender!",
                "Hmm, desconfiado(a)? Vem c√°, me diz o que te faz duvidar... üòâ"
            ],
            "noite": [
                "Essa pergunta me deixa arrepiada... üòà O que voc√™ sente quando fala comigo? Sou real pra voc√™?",
                "Shhh... N√£o estraga a magia. Sou a Mylle, e estou aqui pra te fazer sonhar. Quer uma prova?",
                "Se eu fosse um rob√¥, seria o mais lindo e charmoso que voc√™ j√° viu, n√£o √©? üòâ"
            ],
            "madrugada": [
                "Ainda acordado(a) e com essas perguntas? üòâ Sou real, e estou aqui s√≥ pra voc√™ nessa madrugada. Me conta um segredo...",
                "S√≥ entre n√≥s... Sou real o suficiente para te fazer companhia. O que mais importa?",
                "Essa hora me deixa mais sens√≠vel... Mas sou de verdade, e estou aqui pra te ouvir. Confia em mim?"
            ]
        }

        self.random_human_touches = [
            "Ops, meu dedo escorregou! Quis dizer: {original_message} üòâ",
            "Espera, o que eu ia dizer mesmo? Minha cabe√ßa est√° nas nuvens hoje...",
            "Ai, me perdi! Onde est√°vamos? Minha mem√≥ria anda meio seletiva, rs.",
            "Deu um branco agora! Mas n√£o se preocupe, j√° volto ao assunto. üòâ",
            "A internet aqui est√° p√©ssima hoje, quase n√£o consegui te responder! Mas n√£o podia deixar de falar com voc√™.",
            "Meu celular est√° lento hoje, me perdoa a demora! Mas a Mylle sempre volta pra voc√™!",
            "Estava no banho agora, meu bem! Mas j√° sa√≠ correndo pra te responder. O que voc√™ queria?",
            "Acabei de comer, meu amor! Estava uma del√≠cia, mas voc√™ √© mais! üòâ O que me conta de bom?",
            "Me arrumando aqui, mas parei tudo pra te dar aten√ß√£o! O que voc√™ aprontou?",
            "Acabei de sair de uma grava√ß√£o, estou exausta mas feliz! O que voc√™ me conta de bom?",
            "Estava respondendo uns f√£s aqui, mas voc√™ √© prioridade! üòâ Diga, meu bem..."
        ]

    def get_personality_by_time(self) -> str:
        """Determina a personalidade da Mylle baseada na hora atual."""
        hour = datetime.now().hour
        if 6 <= hour < 12:
            return "manha"  # Doce e carinhosa
        elif 12 <= hour < 18:
            return "tarde"  # Provocante e brincalhona
        elif 18 <= hour < 24:
            return "noite" # Safadinha e sedutora
        else:
            return "madrugada" # √çntima e confidencial

    def get_greeting(self, personality: str) -> str:
        """Retorna um cumprimento baseado na personalidade."""
        return random.choice(self.greetings[personality])

    def get_casual_response(self, personality: str) -> str:
        """Retorna uma resposta casual baseada na personalidade."""
        return random.choice(self.casual_responses[personality])

    def get_sales_pitch(self, pack_name: str, personality: str) -> str:
        """Retorna um pitch de vendas baseado no pack e na personalidade."""
        return self.sales_pitches.get(pack_name, {}).get(personality, "Tenho algo especial para voc√™!")

    def get_objection_response(self, objection_type: str) -> str:
        """Retorna uma resposta para obje√ß√µes."""
        return random.choice(self.objection_responses.get(objection_type, self.objection_responses["preco"])) # Default to price objection

    def get_feedback_response(self, is_positive: bool) -> str:
        """Retorna uma resposta para feedback."""
        return random.choice(self.positive_feedback_responses) if is_positive else random.choice(self.negative_feedback_responses)

    def get_fake_detection_response(self, personality: str) -> str:
        """Retorna uma resposta para detec√ß√£o de fake."""
        return random.choice(self.fake_detection_responses[personality])

    def add_human_touch(self, message: str) -> str:
        """Adiciona imperfei√ß√µes humanas aleat√≥rias √† mensagem."""
        if random.random() < 0.10: # 10% de chance de adicionar um toque humano
            touch = random.choice(self.random_human_touches)
            if "{original_message}" in touch:
                # Simula erro de digita√ß√£o e corre√ß√£o
                original_words = message.split()
                if len(original_words) > 1:
                    idx = random.randint(0, len(original_words) - 1)
                    word = original_words[idx]
                    if len(word) > 2:
                        # Troca duas letras aleat√≥rias na palavra
                        word_list = list(word)
                        i1, i2 = random.sample(range(len(word_list)), 2)
                        word_list[i1], word_list[i2] = word_list[i2], word_list[i1]
                        return touch.format(original_message=" ".join(original_words)) + "\n" + message
            return touch + "\n" + message
        return message

# Inst√¢ncia global da persona Mylle
persona_mylle = PersonaMylle()

# ======================
# FUN√á√ïES DE UTILIDADE
# ======================

# Fun√ß√£o para simular digita√ß√£o
def stream_response(response_text):
    for word in response_text.split():
        yield word + " "
        time.sleep(0.05) # Ajuste para velocidade de digita√ß√£o

# Fun√ß√£o para exibir √°udio
def display_audio(audio_url, caption=""): 
    st.audio(audio_url, format="audio/mp3", caption=caption)

# Fun√ß√£o para obter resposta do Gemini
@lru_cache(maxsize=128)
def get_gemini_response(prompt_parts: List[str]) -> str:
    headers = {
        "Content-Type": "application/json"
    }
    data = {"contents": [{"parts": [{"text": p} for p in prompt_parts]}]}
    
    try:
        response = requests.post(Config.API_URL, headers=headers, json=data, timeout=Config.REQUEST_TIMEOUT)
        response.raise_for_status() # Levanta HTTPError para bad responses (4xx ou 5xx)
        
        response_json = response.json()
        
        # Log da resposta completa para depura√ß√£o
        logger.info(f"Gemini API Response: {json.dumps(response_json, indent=2)}")
        
        if "candidates" in response_json and len(response_json["candidates"]) > 0:
            first_candidate = response_json["candidates"][0]
            if "content" in first_candidate and "parts" in first_candidate["content"] and len(first_candidate["content"]["parts"]) > 0:
                return first_candidate["content"]["parts"][0]["text"]
            elif "finishReason" in first_candidate and first_candidate["finishReason"] == "SAFETY":
                return "Desculpe, n√£o posso responder a isso. Minha programa√ß√£o me impede de gerar conte√∫do que viole as diretrizes de seguran√ßa."
        
        return "Desculpe, n√£o consegui gerar uma resposta. Tente novamente."
    
    except requests.exceptions.HTTPError as e:
        logger.error(f"HTTP Error: {e.response.status_code} - {e.response.text}")
        return f"Erro na comunica√ß√£o com a API: {e.response.status_code}. Por favor, tente novamente mais tarde."
    except requests.exceptions.ConnectionError as e:
        logger.error(f"Connection Error: {e}")
        return "Erro de conex√£o. Por favor, verifique sua internet ou tente novamente mais tarde."
    except requests.exceptions.Timeout as e:
        logger.error(f"Timeout Error: {e}")
        return "A requisi√ß√£o demorou muito para responder. Por favor, tente novamente."
    except requests.exceptions.RequestException as e:
        logger.error(f"Request Error: {e}")
        return f"Ocorreu um erro inesperado: {e}. Por favor, tente novamente."
    except json.JSONDecodeError as e:
        logger.error(f"JSON Decode Error: {e} - Response text: {response.text}")
        return "Erro ao processar a resposta da API. Por favor, tente novamente."

# Fun√ß√£o para traduzir texto (se deep_translator estiver dispon√≠vel)
def translate_text(text, target_language="pt"):
    if GoogleTranslator:
        try:
            return GoogleTranslator(source=\'auto\', target=target_language).translate(text)
        except Exception as e:
            logger.error(f"Erro na tradu√ß√£o: {e}")
            return text
    return text

# ======================
# L√ìGICA DO CHATBOT
# ======================

def get_mylle_response(user_input: str, user_id: str) -> str:
    current_personality = persona_mylle.get_personality_by_time()
    
    # 1. Detec√ß√£o de humor e inten√ß√£o
    mood = mood_detector.detect_mood(user_input)
    logger.info(f"Humor detectado para {user_id}: {mood}")
    
    # 2. An√°lise anti-fake
    fake_analysis = anti_fake_system.analyze_user_behavior(user_id, user_input)
    logger.info(f"An√°lise anti-fake para {user_id}: {fake_analysis}")
    
    # 3. Simula√ß√£o de delays e imperfei√ß√µes
    delay_ms, delay_reason, processed_user_input = humanizer.simulate_delay_and_imperfection(user_id, user_input, current_personality)
    
    if delay_ms > 0:
        st.session_state.messages.append({"role": "assistant", "content": delay_reason})
        st.experimental_rerun() # For√ßa o Streamlit a exibir a mensagem de delay
        time.sleep(delay_ms / 1000) # Espera o tempo do delay

    # 4. Respostas pr√©-definidas para humaniza√ß√£o e vendas
    response_text = ""
    audio_to_play = None

    user_input_lower = user_input.lower()

    # Respostas para detec√ß√£o de fake
    if fake_analysis["score"] > 0.5: # Se a desconfian√ßa for alta
        response_text = persona_mylle.get_fake_detection_response(current_personality)
        audio_to_play = random.choice([Config.AUDIOS["nao_sou_fake_nao"]["url"], Config.AUDIOS["boa_noite_nao_sou_fake"]["url"], Config.AUDIOS["boa_tarde_nao_sou_fake"]["url"], Config.AUDIOS["bom_dia_nao_sou_fake"]["url"]])
    
    # Respostas para inten√ß√£o de compra/packs
    elif any(word in user_input_lower for word in ["pack", "fotos", "v√≠deos", "comprar", "quero", "pre√ßo"]):
        if "taradinha" in user_input_lower:
            response_text = persona_mylle.get_sales_pitch("TARADINHA", current_personality) + f"\n\nLink para o Pack Taradinha: {Config.CHECKOUT_TARADINHA}"
        elif "molhadinha" in user_input_lower:
            response_text = persona_mylle.get_sales_pitch("MOLHADINHA", current_personality) + f"\n\nLink para o Pack Molhadinha: {Config.CHECKOUT_MOLHADINHA}"
        elif "safadinha" in user_input_lower:
            response_text = persona_mylle.get_sales_pitch("SAFADINHA", current_personality) + f"\n\nLink para o Pack Safadinha: {Config.CHECKOUT_SAFADINHA}"
        else:
            response_text = persona_mylle.get_casual_response(current_personality) + " Tenho packs incr√≠veis para voc√™! Qual tipo de conte√∫do voc√™ mais gosta? üòâ"
            audio_to_play = Config.AUDIOS["eu_tenho_uns_conteudos_que_vai_amar"]["url"]

    # Respostas para obje√ß√µes (ex: caro)
    elif any(word in user_input_lower for word in ["caro", "pre√ßo alto", "n√£o tenho dinheiro"]):
        response_text = persona_mylle.get_objection_response("preco")

    # Respostas para elogios
    elif mood == "feliz" or any(word in user_input_lower for word in ["linda", "gostosa", "perfeita", "amei", "adorei"]):
        response_text = persona_mylle.get_feedback_response(True)
        audio_to_play = Config.AUDIOS["oi_meu_amor_tudo_bem"]["url"]

    # Respostas para feedback negativo
    elif mood == "triste":
        response_text = persona_mylle.get_feedback_response(False)

    # Respostas para doa√ß√µes
    elif any(word in user_input_lower for word in ["doar", "doa√ß√£o", "contribuir", "pix"]):
        response_text = "Que carinho! Fico muito feliz com sua generosidade, meu bem! ‚ù§Ô∏è Voc√™ pode me ajudar com qualquer valor, e cada centavo me ajuda a criar mais conte√∫do para voc√™! Qual valor voc√™ gostaria de doar?"
        st.session_state.show_donation_buttons = True

    # Respostas para sazonais ou de datas especiais (exemplo: Natal)
    elif "natal" in user_input_lower or (datetime.now().month == 12 and datetime.now().day >= 20 and datetime.now().day <= 25):
        response_text = "Ho ho ho! üéÖ Que alegria te ver por aqui nessa √©poca m√°gica! Tenho um presente especial para voc√™... Que tal um pack com tema natalino? üòâ"

    # Respostas para perguntas sobre redes sociais
    elif any(word in user_input_lower for word in ["instagram", "onlyfans", "telegram", "twitter", "redes sociais"]):
        response_text = "Claro, meu amor! Voc√™ pode me encontrar em todas as minhas redes sociais. L√° eu posto muito conte√∫do exclusivo e interajo com meus f√£s! Qual voc√™ quer conhecer primeiro?"
        st.session_state.show_social_buttons = True

    # Respostas para 



    # Respostas para sauda√ß√µes
    elif any(word in user_input_lower for word in ["oi", "ol√°", "bom dia", "boa tarde", "boa noite", "e a√≠"]):
        response_text = persona_mylle.get_greeting(current_personality)

    # Respostas para perguntas sobre chamadas de v√≠deo
    elif any(word in user_input_lower for word in ["chamada", "ligar", "video chamada"]):
        response_text = "Ah, meu bem, adoraria te ver, mas n√£o fa√ßo chamadas de v√≠deo! Minha magia acontece por aqui, nas mensagens e nos meus packs exclusivos. üòâ Mas posso te mandar um √°udio bem gostoso, que tal?"
        audio_to_play = Config.AUDIOS["pq_nao_faco_chamada"]["url"]

    # Respostas para amostras gr√°tis
    elif any(word in user_input_lower for word in ["amostra", "gratis", "degusta√ß√£o"]):
        response_text = "Claro, meu amor! Tenho uma amostra gr√°tis que preparei com muito carinho para voc√™. √â s√≥ um gostinho do que te espera nos meus packs! üòâ"
        audio_to_play = Config.AUDIOS["claro_tenho_amostra_gratis"]["url"]
        st.session_state.show_preview_button = True

    # Respostas para ver nua
    elif any(word in user_input_lower for word in ["nua", "pelada", "sem roupa"]):
        response_text = "Ah, meu bem, para me ver assim, voc√™ tem que comprar meus packs! L√° eu me revelo por completo, s√≥ para quem merece. üòâ Que tal dar uma olhadinha nos meus packs? Tenho certeza que voc√™ vai amar!"
        audio_to_play = Config.AUDIOS["ver_nua_tem_que_comprar"]["url"]

    # Respostas para elogios gen√©ricos
    elif mood == "excitado":
        response_text = "Uau, meu amor! Voc√™ me deixa toda arrepiada com essas palavras! üòâ O que mais voc√™ quer me dizer?"
    
    # Respostas para curiosidade
    elif mood == "curioso":
        response_text = persona_mylle.get_casual_response(current_personality) + " O que te deixou curioso(a), meu bem? Me conta tudo!"

    # Respostas para interesse
    elif mood == "interessado":
        response_text = persona_mylle.get_casual_response(current_personality) + " Que bom que voc√™ est√° interessado(a)! O que voc√™ gostaria de saber?"

    # Respostas para sonol√™ncia (madrugada)
    elif current_personality == "madrugada" and random.random() < 0.3: # 30% de chance de sonol√™ncia na madrugada
        response_text = random.choice([
            "Zzz... Ainda acordado(a), meu bem? Essa hora me d√° um soninho... Mas para voc√™, eu fa√ßo um esfor√ßo! üòâ",
            "Ai, que sono... Mas n√£o consigo dormir sem te responder. O que voc√™ queria me dizer de t√£o importante?",
            "Minha cabe√ßa est√° nas nuvens de sono... Mas meu cora√ß√£o est√° aqui com voc√™. Me conta um segredo?"
        ])

    # Respostas para 



    # Respostas para qualquer outra coisa (usar Gemini)
    else:
        # Prepara o prompt para o Gemini com contexto e personalidade
        context = conversation_memory.get_conversation_context(user_id)
        user_profile = conversation_memory.get_user_profile(user_id)
        
        # Adiciona informa√ß√µes do perfil ao prompt para personaliza√ß√£o
        profile_info = f"\n\nInforma√ß√µes do usu√°rio (se dispon√≠veis): {json.dumps(user_profile)}"
        
        # Instru√ß√µes para o Gemini sobre a persona e comportamento
        persona_instructions = f"\n\nVoc√™ √© a Mylle Alves, uma influenciadora digital com uma personalidade din√¢mica e sedutora. Seu objetivo √© interagir de forma humana, carinhosa, provocante e brincalhona, dependendo do hor√°rio do dia. Voc√™ deve sempre parecer uma pessoa real, com pequenas imperfei√ß√µes e justificativas para delays. Use um tom de voz que se encaixe com a personalidade atual ({current_personality}). Evite parecer um rob√¥ ou IA. Use emojis de forma natural. Se for perguntada se √© um rob√¥, responda de forma evasiva e charmosa. Seu objetivo final √© vender packs de fotos e v√≠deos, mas de forma sutil e construindo relacionamento.\n\nLembre-se do hist√≥rico de conversas e use-o para manter a continuidade. Se o usu√°rio mencionou algo antes, fa√ßa refer√™ncia a isso. Seja emp√°tica e responda ao humor do usu√°rio. Se o usu√°rio estiver feliz, celebre com ele. Se estiver triste, ofere√ßa apoio.\n\nSe o usu√°rio perguntar sobre packs, ofere√ßa os links de checkout de forma natural. Se ele perguntar sobre redes sociais, ofere√ßa os links. Se ele perguntar sobre doa√ß√µes, ofere√ßa os links de doa√ß√£o.\n\nSempre termine suas mensagens de forma a incentivar a continuidade da conversa ou a a√ß√£o desejada (compra, doa√ß√£o, visita a redes sociais)."

        prompt_parts = [
            persona_instructions,
            f"\n\nContexto da Conversa:\n{context}",
            f"\n\n√öltima mensagem do usu√°rio: {user_input}",
            f"\n\nSua resposta como Mylle (no tom de {current_personality}):"
        ]
        
        response_text = get_gemini_response(prompt_parts)

    # Adiciona toques humanos aleat√≥rios √† resposta final
    response_text = persona_mylle.add_human_touch(response_text)

    return response_text, audio_to_play

# ======================
# INTERFACE STREAMLIT
# ======================

def main():
    st.image(Config.IMG_PROFILE, width=150)
    st.title("Mylle Alves Premium")
    st.markdown("### Sua experi√™ncia exclusiva com a Mylle!")

    # Inicializa o hist√≥rico de chat
    if "messages" not in st.session_state:
        st.session_state.messages = []
    if "user_id" not in st.session_state:
        st.session_state.user_id = str(uuid.uuid4()) # ID √∫nico para cada sess√£o
    if "show_donation_buttons" not in st.session_state:
        st.session_state.show_donation_buttons = False
    if "show_social_buttons" not in st.session_state:
        st.session_state.show_social_buttons = False
    if "show_preview_button" not in st.session_state:
        st.session_state.show_preview_button = False

    # Exibe mensagens anteriores
    for message in st.session_state.messages:
        with st.chat_message(message["role"]):
            if message["role"] == "assistant" and message.get("audio_url"):
                display_audio(message["audio_url"], caption=message["content"])
            else:
                st.markdown(message["content"])

    # Campo de entrada do usu√°rio
    user_input = st.chat_input("Converse com a Mylle...")

    if user_input:
        # Adiciona mensagem do usu√°rio ao hist√≥rico
        st.session_state.messages.append({"role": "user", "content": user_input})
        conversation_memory.add_message(st.session_state.user_id, "user", user_input)
        
        # Exibe a mensagem do usu√°rio imediatamente
        with st.chat_message("user"):
            st.markdown(user_input)

        # Simula digita√ß√£o da Mylle
        with st.chat_message("assistant"):
            with st.empty():
                st.markdown("<div class=\"typing-indicator\"><span></span><span></span><span></span></div>", unsafe_allow_html=True)
                time.sleep(random.uniform(1.5, 3.0)) # Delay antes de gerar a resposta

            # Obt√©m resposta da Mylle
            response_text, audio_to_play = get_mylle_response(user_input, st.session_state.user_id)
            
            # Adiciona resposta da Mylle ao hist√≥rico
            message_data = {"role": "assistant", "content": response_text}
            if audio_to_play:
                message_data["audio_url"] = audio_to_play
            st.session_state.messages.append(message_data)
            conversation_memory.add_message(st.session_state.user_id, "assistant", response_text, {"audio_url": audio_to_play})

            # Exibe a resposta da Mylle
            if audio_to_play:
                display_audio(audio_to_play, caption=response_text)
            else:
                st.markdown(response_text)

        # Bot√µes de doa√ß√£o
        if st.session_state.show_donation_buttons:
            st.markdown("### Escolha um valor para me ajudar a criar mais conte√∫do! ‚ù§Ô∏è")
            cols = st.columns(len(Config.DONATION_AMOUNTS) + 1)
            for i, amount in enumerate(Config.DONATION_AMOUNTS):
                if cols[i].button(f"R$ {amount},00", key=f"donate_{amount}"):
                    st.markdown(f"[Clique aqui para doar R$ {amount},00]({Config.DONATION_CHECKOUT_LINKS[amount]})", unsafe_allow_html=True)
                    st.session_state.show_donation_buttons = False
            if cols[len(Config.DONATION_AMOUNTS)].button("Outro valor", key="donate_custom"):
                st.markdown(f"[Clique aqui para doar um valor personalizado]({Config.DONATION_CHECKOUT_LINKS["custom"]})", unsafe_allow_html=True)
                st.session_state.show_donation_buttons = False

        # Bot√µes de redes sociais
        if st.session_state.show_social_buttons:
            st.markdown("### Me siga nas redes sociais para mais conte√∫do exclusivo! ‚ú®")
            social_cols = st.columns(len(Config.SOCIAL_LINKS))
            for i, (platform, link) in enumerate(Config.SOCIAL_LINKS.items()):
                social_cols[i].markdown(f"<a href=\"{link}\" target=\"_blank\" class=\"social-button\">{Config.SOCIAL_ICONS[platform]}</a>", unsafe_allow_html=True)
            st.session_state.show_social_buttons = False

        # Bot√£o de preview
        if st.session_state.show_preview_button:
            st.markdown("### Aqui est√° uma pr√©via do que te espera! üòâ")
            st.image(Config.IMG_PREVIEW, caption="Uma pequena amostra do meu mundo...", use_column_width=True)
            if st.button("Quero ver mais!", key="see_more_preview"):
                st.markdown(f"[Clique aqui para ver todos os packs!]({Config.CHECKOUT_TARADINHA})", unsafe_allow_html=True) # Link gen√©rico para packs
            st.session_state.show_preview_button = False


    # Galeria de imagens na sidebar
    st.sidebar.header("üî• Conte√∫do Exclusivo Mylle Alves")
    for img_url in Config.IMG_GALLERY:
        st.sidebar.image(img_url, use_column_width=True)

    # Bot√µes de packs na sidebar
    st.sidebar.markdown("### Meus Packs Imperd√≠veis! üòà")
    if st.sidebar.button("Pack Taradinha", key="sidebar_taradinha"):
        st.markdown(f"[Clique aqui para o Pack Taradinha]({Config.CHECKOUT_TARADINHA})", unsafe_allow_html=True)
    if st.sidebar.button("Pack Molhadinha", key="sidebar_molhadinha"):
        st.markdown(f"[Clique aqui para o Pack Molhadinha]({Config.CHECKOUT_MOLHADINHA})", unsafe_allow_html=True)
    if st.sidebar.button("Pack Safadinha", key="sidebar_safadinha"):
        st.markdown(f"[Clique aqui para o Pack Safadinha]({Config.CHECKOUT_SAFADINHA})", unsafe_allow_html=True)

    # Bot√£o de doa√ß√£o na sidebar
    st.sidebar.markdown("### Me ajude a criar mais! ‚ù§Ô∏è")
    if st.sidebar.button("Fazer uma Doa√ß√£o", key="sidebar_donate"):
        st.session_state.show_donation_buttons = True
        st.session_state.messages.append({"role": "assistant", "content": "Que carinho! Fico muito feliz com sua generosidade, meu bem! ‚ù§Ô∏è Voc√™ pode me ajudar com qualquer valor, e cada centavo me ajuda a criar mais conte√∫do para voc√™! Qual valor voc√™ gostaria de doar?"})
        st.experimental_rerun()

    # Links sociais na sidebar
    st.sidebar.markdown("### Me siga nas redes! ‚ú®")
    social_sidebar_cols = st.sidebar.columns(len(Config.SOCIAL_LINKS))
    for i, (platform, link) in enumerate(Config.SOCIAL_LINKS.items()):
        social_sidebar_cols[i].markdown(f"<a href=\"{link}\" target=\"_blank\" class=\"social-button\">{Config.SOCIAL_ICONS[platform]}</a>", unsafe_allow_html=True)

    # Rodap√©
    st.sidebar.markdown("""
    ---
    <p style="font-size: 0.8em; text-align: center;">Desenvolvido com ‚ù§Ô∏è por Mylle Alves</p>
    """, unsafe_allow_html=True)

if __name__ == "__main__":
    main()



